---
title: "EDA and Feature Engineering"
output:
  html_document:
    df_print: paged
    highlight: tango
    number_sections: yes
    theme: paper
    toc: yes
    toc_depth: 5
  pdf_document:
    toc: yes
    toc_depth: '5'
---
In this competition, we have to find whether the user will repeat the song within the next one month.  
Loading the required Packages

```{r Loading Packages, message=FALSE, warning=FALSE}
library(tidyverse)
library(feather)
library(data.table)
library(viridis)
library(DT)
library(lubridate)
library(magrittr)
library(xgboost)
library(keras)
library(ranger)
# options(tibble.print_max = 5, tibble.print_min = 5)
```

Let's start with EDA on individual data frame and then proceed to their interactions,
  
# EDA

## TRAIN

We will see how each variable in the train DF affects the target.  
Reading in the train data set,
```{r train read, message=FALSE, warning=FALSE, results=FALSE, echo=FALSE}
train <- as.tibble(fread('/Users/kailukowiak/Data_607_Final_Project/train.csv'))
```
Let's look at the data,
```{r show train, message=FALSE,result='asis', warning=FALSE, echo=FALSE}
train
#datatable(head(train,5), style="bootstrap", class="table-condensed", options = list(dom = 'tp',scrollX = TRUE))
```
source_system_tab, source_screen_name and source_type are categorical.  
Let's see how these variables affect the target.

Defining useful functions , 
```{r train - useful functions}
## ggplot setting for readable labels
readable_labs <- theme(axis.text=element_text(size=12),
                     axis.title=element_text(size=14),
                     plot.title = element_text(hjust = 0.5))

# Function to dislpay count of each category of the column and plot how it affects target
target_vs_column <-function(df, col_name, x , y, title)
                  {
  
                  temp_df <- df %>% 
                          group_by_(col_name) %>% 
                          summarize(count = n(), mean_target = mean(target)) %>% 
                          arrange(desc(mean_target)) 
                  
                  df_plot <- temp_df %>%  
                            ggplot(aes_string(col_name, "mean_target")) + 
                            geom_col(aes(fill=count)) +
                            scale_fill_gradient(low='turquoise', high = 'violet')+
                            coord_flip() +
                            labs(x = x,
                                 y = y,
                                 title= title) +
                            readable_labs
                          
                  print(df_plot)
                  return (temp_df)
                  
                  }

# Function to group songs and user by count and check it agains mean_target
target_vs_colcount <- function(df, col_name, x, y, title)
                    { 
  
                    df %>% 
                      group_by_(col_name) %>% 
                      summarize(count = n(), mean_target = mean(target)) %>% 
                      group_by(count) %>% 
                      summarize(new_count = n(), avg_target = mean(mean_target)) %>% 
                      rename(no_of_items = new_count, occurence = count) %>% 
                      print %>% 
                      arrange(desc(avg_target)) %>% 
                      print %>% 
                      ggplot(aes(occurence, avg_target)) +
                        geom_line(color='turquoise') +
                        geom_smooth(color='turquoise') +
                        labs(x = x,
                             y = y,
                             title= title) +
                        readable_labs

                  
                  }

```

### Train column count and its effect on target {.tabset}

#### source_system_tab

We can see that my library has the most count and setting has the least count in the data set.    
It looks like songs are played mostly through my library, search, radio and discover.  
Can one really play a song from settings menu? Or the song was initiated (through a playlist?) when the user was in settings menu?  

One interesting thing is that, if the song is from my library then it is more likely to be replayed within a month and if it is from radio then it is less likely.  
My library is where the user stores their songs locally and hence they really love that song, leading to high mean_target.  
On contrary, radio is a random shuffle of songs and hence the user likeability is not predefined leading to low mean_target.  

```{r sst}
target_vs_column(train, col_name = "source_system_tab",
                  x = 'Frequency',
                  y = 'Target',
                  title = 'Count of source_system_tab vs Target')
```

#### source_screen_name

Similar to source system tab, we can see that screens associated with my library have the most count.  
Looks like KKBox users prefer downloaded music than live streaming. 
Payment (purchasing a single song?) has the highest repeatability but the count of that category is only 12 in the entire data set.  
Local songs in general has higher repeatability.  


```{r ssn}
target_vs_column(train, col_name = "source_screen_name",
                  x = 'Frequency',
                  y = 'Target',
                  title = 'Count of source_screen_name vs Target')
```

#### source_type
Songs appearing in local playlist has a slightly more repeatability than local library.  
May be the user liked the song so much to include in their local playlist that positively affects repeatability.  


```{r st}
target_vs_column(train, col_name = "source_type",
                  x = 'Frequency',
                  y = 'Target',
                  title = 'Count of source_type vs Target')
```

### Song count and User count vs target {.tabset}

Song id and user id pair are unique in train data set

#### Song count vs Target

Songs are grouped together and their count is checked against the target variable.  
The count of a song present in the train data set is almost linearly associated with the mean_target.  
Assuming the train data set is randomnly drawn from the population, the more the song occurs the more it is discoverable by the user.  
This plots shows the relationship between discoverability vs mean_target.  

You could see that there are 166766 songs that are appearing only once and has a lower mean_target and a single song that is appearing 13293 time	that has a higher mean_target.  

```{r song count, message=FALSE, warning=FALSE}
target_vs_colcount(train, "song_id", "Song Occurence", "Target", "Song Occurence vs Target")
```

#### User count vs Target

If the user occurs more in the train data set (frequent listener) then it does not mean that they are more probable to repeat, given by the flat trend.  
```{r user count, message=FALSE, warning=FALSE}
target_vs_colcount(train, "msno", "User Occurence", "Target", "User Occurence vs Target")
```


### Target is balanced

```{r}
train %>% 
  group_by(target) %>% 
  count
```


## MEMBERS

```{r read members, echo=FALSE, message=FALSE, warning=FALSE, results=FALSE}
members <- as.tibble(fread('/Users/kailukowiak/Data_607_Final_Project/members.csv'))
```

Let's look at the members df,

```{r display members, echo=FALSE}
members
```

In members DF, city, bd, gender, registered via are categorical and registration init and expiration date are dates.
Useful functions,

```{r members function}
members_colgroup <- function(df,col_name, x, y, title, xmin, xmax, ymin, ymax)
                    {
                      
                    temp_df <- df %>% 
                                  group_by_(col_name) %>% 
                                  count() %>% 
                                  arrange(desc(n))
                    
                    df_plot <- temp_df %>% 
                                    ggplot(aes_string(col_name, "n")) + 
                                    geom_col(fill='goldenrod2') + 
                                    labs(x = x,
                                         y = y,
                                         title = title) +
                                    xlim(xmin, xmax) +
                                    ylim(ymin, ymax) +
                                    readable_labs
                    
                    print(df_plot)
                    return(temp_df)

}

members_date_count <- function(df, col_name, x, y, title)
{
                            df %>% 
                                group_by_(month = month(col_name), year = year(col_name)) %>% 
                                count() %>% 
                                ungroup %>% 
                                mutate(date = as.Date(paste(as.character(year), as.character(month), '01', sep='-')))
                                ggplot(aes(date, n))+
                                geom_line(color='goldenrod2', size=1) +
                                labs(x = x,
                                     y = y,
                                     title= title) +
                                xlim(xmin, xmax) +
                                readable_labs
}


```

### Distribution of city, bd(age), gender {.tabset}

#### Age

As mentioned in the data dictionary there seems to be outliers in the age field. There are negative values as well as values above 1000.  
Sorted bd vs Frequency is shown in the tibble as well as the graph.  
There are 19932 records with 0 as age. This could be either outliers or missing values.  
Plotting in the age range 1 -100 to show the real distribution.  


```{r age tab, warning=TRUE}
members_colgroup(members, "bd", "Age", "Frequency", "Age Distribution", 1, 100, 0, 1000)
```

#### City

City 1 seems to be highly dominating. But the number 19445 seems suspicious as it is close to the number of records with zero age.  
City1 is also far from other city counts.  

```{r city tab, warning=TRUE}
members_colgroup(members, "city", "City", "Frequency", "City Distribution", 0, 25, 0, 20000)
```


#### Gender

Male and female are almost equal. We have a lot of missing gender.
```{r gender tab, warning=TRUE}
members %>% 
  group_by(gender) %>% 
  count
```


#### Registered_via

Registration methods seem to be dominated mainly by 3,4,7 and 9.

```{r reg tab, warning=TRUE}
members_colgroup(members, "registered_via", "Registration Method", "Frequency", "Registration method Distribution", 0, 16, 0, 15000)
```


Setting date type,

```{r date conversion}
members %<>% 
      mutate(registration_init_time = ymd(registration_init_time),
             expiration_date = ymd(expiration_date))
```

### Signup vs Expiration 


We have members as far as 2005. 
But mostly we have users who signed up between later part of 2016 and early part of 2017. 
Almost 1/3 of the members have an expiration date of 9/2017.

```{r signup vs expiration, message=FALSE, warning=FALSE}
#members_date_count(members, "registration_init_time", "Signup Date", "Number of Users", "Signup vs User Count")
reg_count <- members %>% 
    group_by(month = month(registration_init_time), year = year(registration_init_time)) %>% 
    count() %>% 
    ungroup %>% 
    mutate(date = as.Date(paste(as.character(year), as.character(month), '01', sep='-'))) %>% 
    arrange(desc(n)) %>% 
    print

exp_count <- members %>% 
    group_by(month = month(expiration_date), year = year(expiration_date)) %>% 
    count() %>% 
    ungroup %>% 
    mutate(date = as.Date(paste(as.character(year), as.character(month), '01', sep='-'))) %>% 
    arrange(desc(n)) %>% 
    print

reg_count %>% 
  left_join(exp_count, by="date") %>% 
  ggplot() +
  geom_line(aes(date, n.x), color='goldenrod2') +
  geom_line(aes(date, n.y), color='mediumorchid') +
  labs(y="Frequency", title="Registration and Expiration Distribution")+
  readable_labs
  
```

### Missingness in members

City (marked as '1'), gender( empty character) and age(marked as 0) seems to be missing values.  
While signing up for the app, may be these columns where not mandatory and the co existence of these values should point that  
they arised from the same place.

There are 18356 records that match all three condition. There is certainly relationship between these missingness.  
Gender and age missingness seems to be even more aggressive.  

```{r members missingness}
members %>% 
  mutate(cga = if_else(((city == 1) & (bd == 0) & (gender == "")), 1, 0),
         cg =  if_else(((city == 1) & (gender == "")), 1, 0),
         ca = if_else(((city == 1) & (bd == 0)), 1, 0),
         ga =  if_else(((bd == 0) & (gender == "")), 1, 0)) %>% 
  summarize(city_gender_age = sum(cga),
            city_gender = sum(cg),
            city_age = sum(ca),
            gender_age =sum(ga))
```




## SONGS

```{r songs read, echo=FALSE, message=FALSE, results=FALSE, warning=FALSE, echo=FALSE}
songs <- as.tibble(fread('/Users/kailukowiak/Data_607_Final_Project/songs.csv')) 
```

Songs DF,

```{r songs display}
songs
```

### Top Items{.tabset}

Let's see top 100 frequent items in each category,

```{r top 100 function}
top_100 <- function(df, col_name)
{
  temp_df <- df %>% 
    group_by_(col_name) %>% 
    count %>% 
    arrange(desc(n)) %>% 
    print
  
  return(temp_df)
}
```


#### Top 100 Artists

```{r top 100 artist}
artist_count <- top_100(songs, "artist_name")
```

#### Top 100 Lyricist

```{r top 100 lyricist}
lyricist_count <- top_100(songs, "lyricist")
```

#### Top 100 composer

```{r top 100 composer}
composer_count <- top_100(songs, "composer")
```

#### Top 100 Language

```{r top 100 language}
language_count <- top_100(songs, "language")
```


`r sum(songs$artist_name == songs$lyricist)` songs have same artist and lyricist name.  
`r sum(songs$lyricist == songs$composer)` songs have same lyricist and composer name.     
`r sum(songs$artist_name == songs$composer)` songs have same artist and composer name.   
`r sum(songs$artist_name == songs$lyricist)`songs have same artist and lyricist name.  



#### Top Genre's
  
Genre id is a multi label column with a minumum label of 1 to a maximum label of 8.  
There are 192 unique genres. There are some missing values as well.

```{r top genres, message=FALSE, warning=FALSE}
genre_count <- songs %>% 
                  separate(genre_ids, c("one", "two", "three", "four", "five", "six", "seven", "eight"), extra="merge") %>% 
                  select(one:eight)%>% 
                  gather(one:eight, key="nth_id", value="genre_ids", na.rm=TRUE) %>% 
                  group_by(genre_ids) %>% 
                  count %>% 
                  arrange(desc(n)) %>% 
                  print()
```

##### Distribution of song length

Song length range from 0.003 minutes to 202.89 minutes.
There are 13623 records that have length more than 15 minutes.  

```{r song length dist, message=FALSE, warning=FALSE}
songs %>% 
  mutate(song_length = song_length/6e4) %>% 
  ggplot(aes(song_length)) +
  geom_histogram(binwidth = 0.25, fill='darkorchid3') +
  labs(x='Song Length', y = 'Frequency', title = 'Distribution of song length') +
  xlim(0, 15)
```



## TEST

```{r read test, message=FALSE, warning=FALSE}
test <- as.tibble(fread('/Users/kailukowiak/Data_607_Final_Project/test.csv'))
```

Let's compare the test and train data frames.

### Distribution of test and train on columns {.tabset}

```{r}
test_train_plot <- function(train, test, col_name, x, y)
  {
  test %>% 
  group_by_(col_name) %>% 
  summarize(count = n()) %>% 
  left_join(train %>% 
              group_by_(col_name) %>% 
              summarize(count = n()) , by=col_name) %>% 
  mutate(ratio = count.x/count.y) %>% 
  rename(test_cnt = count.x, train_cnt = count.y) %>% 
  arrange(ratio) %>% 
  print %>% 
  ggplot() +
  geom_col(aes_string(col_name, "train_cnt"), fill='red', alpha = 0.5) +
  geom_col(aes_string(col_name, "test_cnt"), fill='blue', alpha = 0.5) +
  coord_flip() +
  labs(x = x, y= y)+
  readable_labs
}
```

#### Source system tab

Training set had more records from my library compared to test.

```{r, message=FALSE, warning=FALSE}
test_train_plot(train, test, col_name = "source_system_tab", 'Source system tab', 'Test/Train record Count')
```


#### Source screen name

```{r}
test_train_plot(train, test, col_name = "source_screen_name", "Source Screen Name", "Test/Train Count")
```

#### Source system tab

```{r}
test_train_plot(train, test, col_name = "source_type", "Source Type", "Test/Train Count")
```


# Feature Engineering

## Songs Features

Let's create features in the song data frame that indicates the frequency of a particular item in the data set.

```{r}
# <> is from magrittr package that is used for assiging it back the result
songs %<>% 
  left_join(artist_count, by='artist_name') %>% 
  left_join(lyricist_count, by='lyricist') %>% 
  left_join(composer_count, by='composer') %>% 
  left_join(language_count, by='language') %>% 
  rename(art_cnt = n.x, lyr_cnt = n.y, cmp_cnt = n.x.x, lng_cnt = n.y.y)
```

Each song can be tagged with 1-8 genres.
Lets create a feature that shows number og genres a song is tagged to as well as the frequency if each genre.

```{r} 
# Multiple Joins with a smaller data set is much cheaper than lookup
songs %<>% 
      add_column(no_of_genre = 1:dim(.)[1],
                 avg_genre_cnt = 1:dim(.)[1]) %>% 
      separate(genre_ids, c("one", "two", "three", "four", "five", "six", "seven", "eight"), extra="merge") %>% 
      left_join(genre_count, by = c("one" = "genre_ids")) %>% 
      left_join(genre_count, by = c("two" = "genre_ids"), suffix = c(".one", ".two")) %>% 
      left_join(genre_count, by = c("three" = "genre_ids")) %>% 
      left_join(genre_count, by = c("four" = "genre_ids"), suffix = c(".three", ".four")) %>% 
      left_join(genre_count, by = c("five" = "genre_ids")) %>% 
      left_join(genre_count, by = c("six" = "genre_ids"), suffix = c(".five", ".six")) %>% 
      left_join(genre_count, by = c("seven" = "genre_ids")) %>% 
      left_join(genre_count, by = c("eight" = "genre_ids"), suffix = c(".seven", ".eight")) 
```


```{r}
songs %<>% 
      replace_na(list(n.one = 0, n.two = 0, n.three = 0, n.four = 0,
                      n.five = 0, n.six = 0, n.seven = 0, n.eight = 0)) %>% 
      mutate(no_of_genre = (if_else(n.one == 0, 0, 1) + if_else(n.two == 0, 0, 1) +
                            if_else(n.three == 0, 0, 1) + if_else(n.four == 0, 0, 1) +
                            if_else(n.five == 0, 0, 1) + if_else(n.six == 0, 0, 1) +
                            if_else(n.seven == 0, 0, 1) + if_else(n.eight == 0, 0, 1)),
                            avg_genre_cnt = (n.one + n.two + n.three + n.four +
                                             n.five + n.six + n.seven + n.eight)/no_of_genre) %>% 
      select(song_id, song_length, language, art_cnt:lng_cnt, no_of_genre, one, n.one, avg_genre_cnt)
```

## Train Features

```{r}
count_frame <- function(df, col_name, new_name)
{
  return(df %>% 
           group_by_(col_name) %>% 
           count %>% 
           rename_(.dots=setNames('n', new_name)))
}
```


```{r}
train_song_cnt <- count_frame(train, 'song_id', 'song_cnt')
train_sst <- count_frame(train, 'source_system_tab', 'sst_cnt')
train_ssn <- count_frame(train, 'source_screen_name', 'ssn_cnt')
train_st <- count_frame(train, 'source_type', 'st_cnt')
```

```{r}
# Reducing the number of categories into four categories based on interest (approximation)
# 0 - high interest - local and search
# 1 - random on internet
# 2 - random
# 3 - social

train %<>% 
  mutate(sst = ifelse((source_system_tab %in% c('my library', 'search')), 0, 
               ifelse((source_system_tab %in% c('discover', 'explore', 'radio')), 1,
               ifelse((source_system_tab %in% c('null', '', 'notification', 'settings')), 2, 3)))) %>%
  mutate(ssn = ifelse((source_screen_name %in% c('Payment', 'My library', 'My library_Search',
                                                 'Local playlist more', 'Search')), 0,
               ifelse((source_screen_name %in% c('Album more', 'Artist more', 'Concert', 'Discover Chart',
                                                 'Discover Feature', 'Discover Genre', 'Discover New',
                                                 'Explore', 'Radio')), 1,
               ifelse((source_screen_name %in% c('People global', 'People local', 'Search Home',
                                                 'Search Trends', ' Self Profile more')), 2, 3)))) %>% 
  mutate(st = ifelse((source_type %in% c('local-library', 'local-playlist')), 0,
                        ifelse((source_type %in% c('artist', 'album', 'my-daily-playlist',
                                                   'online-playlist', 'radio', 'song-based-playlist',
                                                   'top-hits-for-artist', 'topic-article-playlist', 'song')), 1, 2))) 
```

## Train features vs Target {.tabset}

### Source Type


```{r}
target_vs_column(train, col_name = "st",
                  x = 'Frequency',
                  y = 'Target',
                  title = 'Count of source_system_tab vs Target')
  
```

### Source Screen Name

```{r}
target_vs_column(train, col_name = "ssn",
                  x = 'Frequency',
                  y = 'Target',
                  title = 'Count of source_system_tab vs Target')
  
```


### Source System Tab

```{r}
target_vs_column(train, col_name = "sst",
                  x = 'Frequency',
                  y = 'Target',
                  title = 'Count of source_system_tab vs Target')
  
```


```{r}
song_DF = factor(train$song_id)
peopleDF = factor(train$msno)

```

```{r}
library(keras)

```

